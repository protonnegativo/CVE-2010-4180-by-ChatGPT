import socket
import ssl
import argparse
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend

def get_supported_ciphers(hostname, port, tls_version):
    context = ssl.SSLContext(tls_version)
    context.set_ciphers("ALL")
    context.verify_mode = ssl.CERT_NONE

    try:
        with socket.create_connection((hostname, port)) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                return ssock.shared_ciphers()
    except ssl.SSLError:
        return []

def check_vulnerability(hostname, port):
    tls_versions = {
        "TLSv1.0": ssl.PROTOCOL_TLSv1,
        "TLSv1.1": ssl.PROTOCOL_TLSv1_1,
        "TLSv1.2": ssl.PROTOCOL_TLSv1_2,
    }

    supported_ciphers = {}
    for version, protocol in tls_versions.items():
        ciphers = get_supported_ciphers(hostname, port, protocol)
        supported_ciphers[version] = ciphers
        print(f"{version} supported ciphers: {ciphers}")

    # Aqui você pode adicionar a lógica para verificar a vulnerabilidade CVE-2010-4180 com base nas cifras suportadas.
    # Esta é uma implementação simplificada e pode não ser tão completa quanto o script original.
    for version, ciphers in supported_ciphers.items():
        if len(ciphers) > 1:
            print(f"[+] {hostname}:{port} might be vulnerable to CVE-2010-4180 for {version}")
        else:
            print(f"[-] {hostname}:{port} is NOT vulnerable to CVE-2010-4180 for {version}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--target", required=True, help="target server (e.g. 4.2.2.2:443)")
    args = parser.parse_args()

    if ":" not in args.target:
        hostname = args.target
        port = 443
    else:
        hostname, port = args.target.split(":")
        port = int(port)

    check_vulnerability(hostname, port)
